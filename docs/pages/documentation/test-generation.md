---
permalink: /documentation/test-generation/
title: "Test Generation"
toc: false
classes: wide
sidebar: docs_sidebar
---

## Planning

Automating test creation is the real power behind Simulato as a testing solution. When thinking about traditional `Selenium` test scripts most are hand written, down a specific path through a system, and meant to test a specific feature. This limits testing, often unintentionally, to creating tests that can only be thought up by the individual writing the tests. By creating algorithms that generate tests for us based on the components created to describe the system, we can remove that subjectivity. In addition, we can create different algorithms to solve different testing problems for a system using the same set of components. This is the general theory behind model based testing, and why there is a lot of potential for getting high test coverage.  This document will describe the process that Simulato does when generating tests.Au

The heart of test generation is the search algorithm that is used to generate the tests. As of right now, Simulato uses only one simple search algorithm, `forward state space search`.  We have tailored the basic concepts of `forward state space search` with a custom heuristic to increase efficiency, finding ways for the algorithm to work faster for our specific problem. The `coverage criteria` of performing every action modeled out by the system components, named `action coverage`, must be met which ensures that every action is performed at least once.  Deep knowledge of our algorithm, or any other algorithm implemented in the future, is not needed to understand the base concepts of what Simulato uses to generate tests.  To understand how tests are generated we need to talk about a few important concepts: the `expected state`, `preconditions`, `effects`. This will give us the basis for how Simulato uses these three concepts to simulate the execution of tests to generate test plans.

Whenever a component is added to the `expected state`, either through an entry component, from the `effects` of an action, or as a `child` of component, we are telling Simulato what we expect the state of that component to be in at the given point of time inside the system. As we build out components to model our system under test, we continually modify, add to, and delete from the `expected state`. This describes how we expect the state to change as we perform `actions`.  When creating actions, only the `preconditions` and `effects` directly interact with `expected state`, while the `perform` is where we describe how to act upon the system which casuses the expected `effects`.  

During planning, Simulato uses the `expected state` that we have specified to generate tests. Simulato does not have access to the system at this point, planning is entirely separate for the system under test. This means that the `perform` block is never run and only the `preconditions` and `effects` blocks are run when generating tests. What this means is the `page state` is never accounted for, in any way, during planning. At all during simulated test execution, Simulato keeps track of the entire `expected state` that has been described by the combination of current components added to the `expected state`. It then uses the `expected state` to find `actions` that can be performed given the current `expected state`. Simulato does this by processing each component's `actions`, finding if their `preconditions` are met by the `expected state`. When an `action`'s `preconditions` are met, and since every action has an `effects` section, Simulato will then execute the `effects`. The `effects` will describe what changes we expect that action to have on the state of the system. More specifically, that action will modify the `expected state`. Possible changes to the `expected state` include: new components with new actions can be added, components being removed, or the state of existing components change. Once the effects have been processed, including any and all modifications to the `expected state`, Simulato looks at the newly modified `expected state` to find actions which have `preconditions` that are now met. As new `actions` are found with valid `preconditions`, the test script will continue to add actions, eventually forming a complete test when no new actions are found applicable to the `expected state`.

Simulato only has access to the `expected state` and never the page state for planning. As such, never use part of a model who's `expected state` was filled in by `this.getFromPage()` as a precondition. During planning `this.getFromPage()` will ALWAYS return undefined. This value will be different than during test execution, where the page state can be accessed.
{: .notice--warning}

For Simulato to perform planning, it will need an `expected state` created to use as a starting point to generate tests from. This is the main purpose of an `entry component`.  The `entry component` provides Simulato the means to automatically add a component on to the `expected state`.  At this point in the planning process, Simulato only has the `actions` provided by the `entry component` as available `actions` to choose from during test generation. Most entry components contain only one action, the action that enters us into the system under test. This action has no `preconditions`, so Simulato can always add it as the first action in a test. Once the `effects` of the action are processed, it will add new components, with new actions, to allow test generation to continue. Generation continues until `action coverage` is met, that is, all `actions` described in the system are ran at least once. Once this `coverage criteria` is satisfied, planning will end, and a series of tests will have been created.
