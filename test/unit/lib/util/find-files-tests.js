'use strict';

const mockery = require('mockery');
const sinon = require('sinon');
const expect = require('chai').expect;

describe('lib/util/find-files.js', function() {
  describe('search', function() {
    let fs;
    let path;
    let callback;
    let findFiles;
    let stats;
    let files;
    let paths;
    let myFindFiles;

    beforeEach(function() {
      mockery.enable({useCleanCache: true});
      mockery.registerAllowable('../../../../lib/util/find-files.js');

      callback = sinon.spy();
      stats = {
        isDirectory: sinon.stub(),
        isFile: sinon.stub(),
      };
      files = [
        'path/to/subDir/file',
      ];
      sinon.spy(files, 'map');

      fs = {
        statSync: sinon.stub().returns(stats),
        readdirSync: sinon.stub().returns(files),
      };
      path = {
        resolve: sinon.stub(),
      };
      paths = [
        'path/to/file1',
        'path/to/file2',
        'path/to/file3',
      ];

      sinon.spy(process, 'cwd');

      mockery.registerMock('fs', fs);
      mockery.registerMock('path', path);

      findFiles = require('../../../../lib/util/find-files.js');
      myFindFiles = {
        search: findFiles.search,
      };
      findFiles.search = sinon.stub();
      findFiles.search.callsArgWith(1, ['returned/file/path']);
    });

    afterEach(function() {
      process.cwd.restore();
      mockery.resetCache();
      mockery.deregisterAll();
      mockery.disable();
    });

    describe('for each path in the passed in paths array of length 3', function() {
      it('should call process.cwd for each path', function() {
        myFindFiles.search(paths, callback);

        expect(process.cwd.callCount).to.equal(3);
      });

      it('should call path.resolve for each path with the arguments of cwd that path', function() {
        myFindFiles.search(paths, callback);

        expect(path.resolve.args).to.deep.equal([
          [process.cwd(), paths[0]],
          [process.cwd(), paths[1]],
          [process.cwd(), paths[2]],
        ]);
      });

      it('should call fs.statSync for each absoulute path generated by path.resolve', function() {
        path.resolve.onCall(0).returns('absolutePath1');
        path.resolve.onCall(1).returns('absolutePath2');
        path.resolve.onCall(2).returns('absolutePath3');

        myFindFiles.search(paths, callback);

        expect(fs.statSync.args).to.deep.equal([
          ['absolutePath1'],
          ['absolutePath2'],
          ['absolutePath3'],
        ]);
      });

      it('should call stats.isDirectory for each path all with no args', function() {
        myFindFiles.search(paths, callback);

        expect(stats.isDirectory.args).to.deep.equal([
          [],
          [],
          [],
        ]);
      });

      describe('if stats.isDirectory returns true', function() {
        it('should call fs.readdirSync with the generated absolute path', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);

          myFindFiles.search(paths, callback);

          expect(fs.readdirSync.args).to.deep.equal([
            ['absolutePath1'],
          ]);
        });

        it('should call the returned files from fs.readdirSync .map function once', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);

          myFindFiles.search(paths, callback);

          expect(files.map.callCount).to.equal(1);
        });

        it('should call the returned files from fs.readdirSync .map function with a callback', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);

          myFindFiles.search(paths, callback);

          expect(files.map.args[0][0]).to.be.a('function');
        });

        describe('when the callback is called from files.map', function() {
          it('should call path.resolve a total of 4 times', function() {
            path.resolve.onCall(0).returns('absolutePath1');
            stats.isDirectory.onCall(0).returns(true);

            myFindFiles.search(paths, callback);

            expect(path.resolve.callCount).to.be.deep.equal(4);
          });
          it('should call path.resolve with the this paths abolute path and its path', function() {
            path.resolve.onCall(0).returns('absolutePath1');
            stats.isDirectory.onCall(0).returns(true);

            myFindFiles.search(paths, callback);

            expect(path.resolve.args[1]).to.be.deep.equal([
              'absolutePath1',
              'path/to/subDir/file',
            ]);
          });
        });

        it('should call findFiles.search recursively once', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);

          myFindFiles.search(paths, callback);

          expect(findFiles.search.callCount).to.equal(1);
        });

        it('should call findFiles.search with the generated absolute paths as first param', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);
          path.resolve.onCall(1).returns('absolutePath1/path/to/subDir/file');


          myFindFiles.search(paths, callback);

          expect(findFiles.search.args[0][0]).to.deep.equal([
            'absolutePath1/path/to/subDir/file',
          ]);
        });

        it('should call findFiles.search with a callback as the second param', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);

          myFindFiles.search(paths, callback);

          expect(findFiles.search.args[0][1]).to.be.a('function');
        });

        it('should add to the returned testcases the test cases returned by the recursive call', function() {
          path.resolve.onCall(0).returns('absolutePath1');
          stats.isDirectory.onCall(0).returns(true);

          myFindFiles.search(paths, callback);

          expect(callback.args).to.deep.equal([[
            ['returned/file/path'],
          ]]);
        });
      });

      describe('if stats.isDirectory returns false', function() {
        it('should call stats.isFile for each file that was not a directory', function() {
          path.resolve.onCall(0).returns('absolutePath1');

          myFindFiles.search(paths, callback);

          expect(stats.isFile.args).to.deep.equal([
            [],
            [],
            [],
          ]);
        });

        describe('if states.isFile returns true', function() {
          it('should add to the returned testcases the test cases', function() {
            path.resolve.onCall(0).returns('absolutePath1');
            path.resolve.onCall(1).returns('absolutePath2');
            path.resolve.onCall(2).returns('absolutePath3');
            stats.isFile.returns(true);

            myFindFiles.search(paths, callback);

            expect(callback.args).to.deep.equal([[
              ['absolutePath1', 'absolutePath2', 'absolutePath3'],
            ]]);
          });
        });
      });
    });
  });
});
